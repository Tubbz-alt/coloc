#pragma once

#include <string>
#include <fstream>
#include "localizationData.hpp"
#include "localizationParams.hpp"

namespace coloc
{
	class Logger
	{
	public:
		bool logMaptoPLY(Scene& scene, std::string& filename);
		bool logPosetoPLY(Pose3& pose, std::string& filename);
		bool logPoseCovtoFile(int source, int dest, Pose3& pose, Cov6& cov, std::string& filename);
	};

	bool Logger::logPoseCovtoFile(int source, int dest, Pose3& pose, Cov6& cov, std::string& filename)
	{
		std::ofstream file;

		Vec3 position = pose.translation();
		file.open(filename, std::ios::out | std::ios::app);
		if (file.fail())
			throw std::ios_base::failure(std::strerror(errno));

		//make sure write fails with exception if something is wrong
		file.exceptions(file.exceptions() | std::ios::failbit | std::ifstream::badbit);

		file << dest << "," << source << "," << position[0] << "," << position[1] << "," << position[2] << ",";
		file << cov.at(0)[21] << "," << cov.at(0)[28] << "," << cov.at(0)[35] << std::endl;

		bool logStatus = file.good();
		return logStatus;
	}

	bool Logger::logPosetoPLY(Pose3& pose, std::string& filename)
	{
		std::ofstream stream(filename.c_str(), std::ios::out | std::ios::app);
		if (!stream.is_open())
			return false;

		stream << std::fixed << std::setprecision(std::numeric_limits<double>::digits10 + 1);

		using Vec3uc = Eigen::Matrix<unsigned char, 3, 1>;
		stream
			<< pose.center()(0) << ' '
			<< pose.center()(1) << ' '
			<< pose.center()(2) << ' '
			<< "0 255 0\n";

		bool logStatus = stream.good();
		return logStatus;
	}

	bool Logger::logMaptoPLY(Scene& scene, std::string& filename)
	{
		std::ofstream stream(filename.c_str(), std::ios::out | std::ios::binary);
		if (!stream.is_open())
			return false;

		stream << std::fixed << std::setprecision(std::numeric_limits<double>::digits10 + 1);

		using Vec3uc = Eigen::Matrix<unsigned char, 3, 1>;

		stream << "ply"	<< '\n' << "format " << "ascii 1.0"
			<< '\n' << "comment generated by coloc"
			<< '\n' << "element vertex "
			<< scene.GetLandmarks().size()
				+ scene.GetPoses().size()
			<< '\n' << "property double x"
			<< '\n' << "property double y"
			<< '\n' << "property double z"
			<< '\n' << "property uchar red"
			<< '\n' << "property uchar green"
			<< '\n' << "property uchar blue"
			<< '\n' << "end_header" << std::endl;

		for (const auto & view : scene.GetViews()) {
			if (scene.IsPoseAndIntrinsicDefined(view.second.get())) {
				const geometry::Pose3 pose = scene.GetPoseOrDie(view.second.get());
				stream
					<< pose.center()(0) << ' '
					<< pose.center()(1) << ' '
					<< pose.center()(2) << ' '
					<< "0 255 0\n";
			}
		}

		const Landmarks & landmarks = scene.GetLandmarks();
		for (const auto & iterLandmarks : landmarks) {
			stream	<< iterLandmarks.second.X(0) << ' '
					<< iterLandmarks.second.X(1) << ' '
					<< iterLandmarks.second.X(2) << ' '
					<< "255 255 255\n";
		}

		stream.flush();
		bool logStatus = stream.good();
		stream.close();

		return logStatus;
	}
}